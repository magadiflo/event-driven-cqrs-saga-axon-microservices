# Sección 11: Validación. Message Dispatch Interceptor

---

## Introducción al Message Dispatch Interceptor

Otra forma de validar un comando antes de que sea procesado y se publique un evento relevante, es utilizar el
`Message Dispatch Interceptor`.

El `message dispatch interceptor` se invoca cuando se envía una orden al bus de órdenes. Recordemos que en el
`ProductCommandController` hemos inyectado la interfaz `CommandGateway`. Este objeto enviará el comando al bus de
comandos y la clase manejadora de comandos `(Command Handler)` consumirá este mensaje del bus de comandos.

Así que podemos escribir un interceptor de envío de mensajes para interceptar el comando justo cuando se envía en un
bus de comandos. Usando interceptores de envío de mensajes, puedes hacer un login adicional, puedes hacer validaciones
de comandos, puedes alterar el mensaje de comando añadiendo metadatos o también se puede bloquear el comando lanzando
una excepción.

![01.png](assets/section-12/01.png)

## Crea una nueva clase Command Interceptor

En el controlador `ProductCommandController`, usamos el `this.commandGateway.sendAndWait(...)` para enviar un
comando llamado `CreateProductCommand`.

Así que lo primero que haremos en este interceptor, será verificar que el comando que estamos interceptando es esa clase
`CreateProductCommand`, dado que es la clase que contiene los valores que queremos validar y que han sido enviados a
través del `CommandGateway`.

Esta validación lo hacemos porque el interceptor no solo interceptará la clase `CreateProductCommand`,
sino también podría interceptar otras clases.

````java

@Slf4j
@Component
public class CreateProductCommandInterceptor implements MessageDispatchInterceptor<CommandMessage<?>> {
    @Nonnull
    @Override
    public BiFunction<Integer, CommandMessage<?>, CommandMessage<?>> handle(@Nonnull List<? extends CommandMessage<?>> messages) {
        return (integer, commandMessage) -> {

            log.info("Comando interceptado: {}", commandMessage.getPayloadType());

            if (CreateProductCommand.class.equals(commandMessage.getPayloadType())) {

                CreateProductCommand payload = (CreateProductCommand) commandMessage.getPayload();

                if (payload.getPrice().compareTo(BigDecimal.ZERO) <= 0) {
                    throw new IllegalArgumentException("El precio no puede ser menor o igual a cero");
                }

                if (Objects.isNull(payload.getQuantity()) || payload.getQuantity() < 0) {
                    throw new IllegalArgumentException("La cantidad debe ser mayor o igual a cero");
                }

                if (Objects.isNull(payload.getTitle()) || payload.getTitle().isBlank()) {
                    throw new IllegalArgumentException("El título no puede estar vacío");
                }
            }

            return commandMessage;
        };
    }
}
````

**Nota**
> Hasta el momento, observamos que tenemos 3 validaciones, que digamos se están repitiendo:
>
> 1. En el endpoint `createProduct(@Valid @RequestBody CreateProductRestModel request)` del controlador
     `ProductCommandController`.
> 2. En el `ProductAggregate(CreateProductCommand createProductCommand)` del `ProductAggregate`.
> 3. En el `CreateProductCommandInterceptor` que es el interceptor que creamos en este apartado.
>
> Solo estamos siguiendo el contenido del curso y lo dejamos, por el momento, para tenerlo como ejemplo, pero más
> adelante eliminaremos y dejaremos solo uno.

