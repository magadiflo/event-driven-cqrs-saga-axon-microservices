# Sección 14: Handle Error & Rollback Transaction

---

## Error Handling: Introducción

En las siguientes lecciones, aprenderá cómo manejar una excepción que es lanzada en el método manejador de
eventos y cómo hacer que retroceda los cambios que ha hecho en la tabla de la base de datos.

Ahora, el manejo de errores que vamos a discutir en los siguientes videos se hace dentro del mismo microservicio.
Hablaremos de cómo manejar un error y cómo revertir una transacción que se extiende a través de múltiples
microservicios distribuidos, pero en una sección diferente, cuando hablemos del patrón de diseño.

Pero en esta sección, hablaremos de cómo manejar un error en el método manejador de eventos y cómo revertir los cambios
que se hacen en un método manejador de eventos diferente.

Esto es muy útil cuando se tienen varios métodos de control de errores y se desea deshacer los cambios realizados en
todos los controladores de errores que se encuentran en el mismo grupo de procesamiento.

Ya has visto cómo manejar una excepción en la clase controladora usando las sentencias try y catch. Lo más probable es
que tu clase controladora tenga múltiples puntos de servicio web y puedas manejar las excepciones en cada uno de tus
puntos de servicio web por separado.

Si lo necesitas, puedes definir una clase separada de manejador de excepciones que esté anotada con la anotación
`@ControllerAdvice` y usar esa clase para manejar diferentes excepciones en un solo lugar. Esto te ayudará a tener
menos citas en cada uno de tus métodos en la clase controladora porque no necesitarás tener try y catch en cada método.

Todas las excepciones se gestionarán en una clase central de gestión de excepciones con una anotación de asesoramiento
de controlador. La sentencia try y catch en los métodos del controlador o en una clase manejadora de excepciones
centralizada te ayudará a manejar las excepciones que se lanzan en la propia clase controladora en el interceptor de
mensajes que hemos creado o en el método manejador de comandos que hemos definido en la clase agregada.

Pero a menos que escribamos un poco más de código Java, no le ayudará a manejar las excepciones que se lanzan en los
métodos manejadores de eventos.

Cuando se lanzan excepciones en los métodos manejadores de eventos, el comportamiento por defecto es bloquear un
mensaje de error y continuar la ejecución. Y debido a que el código y el método manejador de comandos fue ejecutado con
éxito, el evento para crear un nuevo producto tuvo lugar y la aplicación cliente recibirá una respuesta exitosa sin
importar el error en el método manejador de eventos.

![01.png](assets/section-14/01.png)

Si se lanza una excepción y no fue manejada en el método manejador de eventos, no impedirá la ejecución de otros
manejadores de eventos. Se bloqueará una excepción pero la ejecución continuará y el código en otros métodos manejadores
de eventos en el mismo grupo de procesamiento continuará también.

El mensaje de excepción lanzado en el método manejador de eventos tampoco será manejado por la sentencia try y catch en
la clase del controlador o en la clase manejadora de excepciones del `@ControllerAdivice` centralizado.

No se manejará allí a menos que escribamos un poco más de código para cambiar ese comportamiento. Ciertamente, puedes
atrapar un error en el método manejador de eventos usando try y catch y hacer algo al respecto para recuperarte y si es
necesario, también puedes crear métodos manejadores de errores separados en la clase manejadora de eventos para manejar
diferentes excepciones y hacer algo al respecto.

![02.png](assets/section-14/02.png)

Y para hacer eso en la clase manejadora de eventos, crearás uno o múltiples métodos anotados con la anotación manejadora
de excepciones. Pero si quieres que un mensaje de excepción se propague hasta un método del controlador o hasta una
clase de asesoramiento del controlador, tendrás que escribir un código adicional para configurar el procesador de
eventos para que propague la excepción, de modo que puedas capturarla en un lugar diferente y luego volver a lanzar esa
excepción para que bloquee el flujo completo.

Para ello, utilizaremos el `ListenerInvocationErrorHandler` que proporciona `Axon Framework`. Si lo haces, puedes
detener la ejecución en el método manejador de eventos tan pronto como se produzca la excepción. Soplar la ejecución en
todos los métodos manejadores de eventos, manejar y error en la clase controlador y, a continuación, devolver un mensaje
de error personalizado a declinar la aplicación.

La transacción se revertirá y todos los cambios en la base de datos que se prepararon para su ejecución también se
revertirán y no se confirmarán. Para que esto funcione, necesitaremos configurar nuestros métodos manejadores de eventos
para que estén en el mismo grupo de procesamiento que está configurado para usar el procesador de eventos suscriptor.

El procesador de eventos es un componente que se encarga de gestionar los aspectos técnicos de proporcionar los eventos
a sus manejadores de eventos. Y en el momento de grabar estas lecciones en vídeo, los procesadores de eventos vienen
aproximadamente en dos formas, el `seguimiento (tracking)` y la `suscripción (subscribing)`.

Los procesadores de eventos suscriptores `(subscribing event processor)` se suscriben a una fuente de eventos que son
invocados por el hilo gestionado por el mecanismo de publicación. Por otro lado, los procesadores de eventos de
seguimiento `(Tracking event processor)` extraen sus mensajes de una fuente utilizando un hilo que gestiona él mismo.

![03.png](assets/section-14/03.png)

Y por defecto, las excepciones levantadas por los manejadores de eventos son bloqueadas y el procesamiento continúa con
los siguientes eventos.

En el caso del procesador de eventos de seguimiento, esto significa que el procesador pasará al modo de error, liberará
el testigo y volverá a intentar un evento en un intervalo incremental que comienza en un segundo hasta un máximo de 60
segundos. Seguirá intentando procesar ese evento. Comenzará en un segundo y se duplicará tras cada intento hasta
alcanzar un tiempo de espera máximo de 60 segundos por intento. Esta cantidad de tiempo garantiza que si otro nodo es
capaz de procesar eventos con éxito, tendrá la oportunidad de reclamar el token necesario para procesar el evento.

Un procesador de eventos suscrito informará de un error de publicación al componente que proporcionó un evento. Hará que
una excepción burbujee hasta el componente de publicación del evento permitiéndole tratarlo en consecuencia.

Si propagamos una excepción hasta el final, podemos hacer retroceder toda la transacción. Para poder deshacer toda la
transacción, en las siguientes lecciones en vídeo utilizaremos el procesador de eventos de suscripción para gestionar
sus manejadores de eventos en la clase manejadora de eventos de producto.

## Crea una clase centralizada para el manejo de errores

En este apartado vamos a crear la clase que puede manejar los mensajes de error lanzados desde cualquier controlador en
su microservicio. Esto es, gracias a que estamos anotando la clase con `@RestControllerAdvice` y a cada método lo
anotamos con `@ExceptionHandler`.

````java

@RestControllerAdvice
public class ProductServiceErrorHandler {

    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<Object> handleIllegalStateException(IllegalStateException ex, WebRequest request) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ex.getMessage());
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Object> handleGenericException(Exception ex, WebRequest request) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ex.getMessage());
    }

}
````

Ahora, vamos a nuestro controlador `ProductCommandController` y realizamos una pequeña modificación. Recordemos que
anteriormente dentro del método `createProduct()` hacíamos uso del bloque `try-catch` para capturar la excepción
ocurrida, pero ahora, con esta nueva implementación ya no la necesitamos, dado que nuestra clase
`ProductServiceErrorHandler` se encargará de manejar los errores que se lancen.

Por lo tanto, nuestra clase controladora quedaría así, sin ningún bloque `try-catch` (lo dejaré comentado solo para la
documentación).

````java

@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/products")
public class ProductCommandController {

    private final CommandGateway commandGateway;

    @PostMapping
    public String createProduct(@Valid @RequestBody CreateProductRestModel request) {
        CreateProductCommand createProductCommand = CreateProductCommand.builder()
                .price(request.getPrice())
                .quantity(request.getQuantity())
                .title(request.getTitle())
                .productId(UUID.randomUUID().toString())
                .build();

//        String returnValue;
//        try {
//            returnValue = this.commandGateway.sendAndWait(createProductCommand);
//        } catch (Exception e) {
//            returnValue = e.getLocalizedMessage();
//        }
//        return returnValue;
        return this.commandGateway.sendAndWait(createProductCommand);
    }
}
````

## Prueba cómo funciona nuestra clase centralizada para el manejo de errores

Ejecutaremos las aplicaciones en el siguiente orden.

1. Contenedor de Postgres
2. Contenedor de Axon Server
3. Discovery Server
4. Product Service
5. Gateway Server

A continuación, tratamos de registrar un producto cuyo título ya fue registrado anteriormente.

````bash
$ curl -v -X POST -H "Content-Type: application/json" -d "{\"title\": \"Disco Duro SSD\", \"price\": 500, \"quantity\": 2}" http://localhost:8080/api/v1/products
>
< HTTP/1.1 400 Bad Request
< Content-Type: text/plain;charset=UTF-8
< Content-Length: 97
< Date: Tue, 25 Feb 2025 16:02:01 GMT
<
Product with productId 894229d1-cf7d-41c8-a7a8-2f0e5940b7af or title Disco Duro SSD already exist
````

Como observamos, nos está retornando el código de estado `400 Bad Request`, mismo que fue definido en nuestra clase
manejadora de excepciones anotado con `@RestControllerAdvice`.