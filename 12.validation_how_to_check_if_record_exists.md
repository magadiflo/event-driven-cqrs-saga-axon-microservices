# Sección 13: Validación. ¿Cómo comprobar si un registro existe?

En la siguiente sección aprenderemos a realizar la validación de consistencia basada en conjuntos.

---

## Introducción - Consistencia Basada en Conjuntos

Cuando se utiliza patrones de diseño en la construcción de microservicios seguros, una pregunta muy común que se hacen
los desarrolladores es
`¿cómo compruebo si ya existe un registro en una tabla de base de datos antes de crear uno nuevo?`.

Por ejemplo, si estamos creando un nuevo producto en nuestro sistema, **¿cómo comprobamos que no exista ya un producto
con el mismo `ID de producto` o el mismo `title`?, etc.** Esta es una pregunta muy válida porque en las aplicaciones
seguras los modelos de comando y consulta están segregados y para crear un nuevo producto la aplicación cliente enviará
una petición HTTP a una `API de Comandos`. Por otro lado, para consultar los detalles de un producto, una aplicación
cliente enviará una solicitud HTTP a una `API de consulta`. Por lo tanto, existe una separación muy clara de
responsabilidades entre ambas.

Al crear un nuevo producto, la API de cliente primero persistirá un evento en el almacén de eventos (`Event Store`) y
solo después de que el evento se persiste publicará un evento para sincronizar los datos entre el `almacén de eventos`
y la `base de datos de consulta`.

La comunicación entre `Command API` y la `Query API` se realiza mediante mensajería de eventos, que no es instantánea
y la sincronización entre los dos modelos puede llevar algún tiempo debido a la mensajería de eventos.

La coherencia entre los dos modelos es eventual y no es instantánea. Por lo tanto, si en la aplicación segura, la
comunicación entre el Comando y la API de Consulta está dirigida por eventos. Para consultar los detalles del
producto tenemos que ir a través de una API de Consulta.

![01.png](assets/section-13/01.png)

> **¿Cómo puede el Command API comprobar rápidamente si los registros ya existen antes de persistir un evento en el
> almacén de eventos?**

La solución a este problema se analiza en detalle en uno de los artículos del sitio web de `Axon framework`. Puede
encontrarlo buscando `Set Based Consistency Validation` en Google.

[![02.png](assets/section-13/02.png)](https://www.axoniq.io/blog/2020set-based-consistency-validation)

Este problema no tiene nada que ver con `Axon framework` sino con el `patrón de diseño Secures`. Y este artículo trata
de una solución que puedes implementar si estás construyendo tu aplicación con `Axon Framework`.

> En las siguientes lecciones de vídeo, lo implementaremos en nuestra aplicación.

Así que aquí, lo que vamos a hacer, porque el modelo de comandos puede contener cualquier forma de modelo de datos,
vamos a introducir una pequeña tabla de búsqueda que contendrá IDs de productos y títulos de productos.

![03.png](assets/section-13/03.png)

Esta nueva tabla de consulta (`Lookup db table`) formará parte del lado de comandos y no será expuesta por la API de
consulta. Por lo tanto, la aplicación cliente que se comunique con la API de consulta no podrá consultar esta tabla de
consulta, solo será utilizado por el lado del comando.

Cuando la API de comandos gestiona el comando `CreateProductCommand`, primero consulta la tabla de búsqueda para saber
si ya existe el producto con el mismo ID y título; en caso afirmativo, si la tabla de búsqueda contiene el mismo
ID de producto y el título, lanzaremos una excepción y el comando no se procesará. El almacén de eventos no se
actualizará y el nuevo producto no persistirá en la base de datos de consultas. Pero si la tabla de búsqueda no
contiene los detalles de este producto, entonces se procesará el comando `CreateProductCommand` y se creará el nuevo
producto. El título y el ID de producto de un nuevo producto se mantendrán en la tabla de consulta, ¿de acuerdo?

Así pues, algunas cosas importantes sobre esta tabla de consulta.

- No debe contener exactamente los mismos detalles de producto que tiene la base de datos de lectura.
- Esta tabla de búsqueda solo debe almacenar los campos de producto necesarios para buscar el registro y ver si existe.
  Como, por ejemplo, el ID del producto o el título del producto.
- No es necesario almacenar el precio, la cantidad u otros detalles del producto.
- Si la aplicación cliente emite un comando para actualizar el título del producto, por ejemplo, y el título del
  producto es el campo por el que se busca un registro en esta tabla de base de datos de consulta, entonces tendrá que
  actualizar este campo tanto en la tabla de consulta como en su base de datos de consulta. Por lo tanto, los campos
  por los que se consulta el registro en la tabla de consulta deben ser coherentes con la base de datos principal de
  productos leídos.

Ahora, **¿cómo consultamos esta tabla de consulta antes de que el gestor de órdenes procese la orden?** Y la respuesta
es, utilizamos el `interceptor` de envío de mensajes que ya hemos implementado en una de las lecciones de vídeo
anteriores.

El interceptor de envío de mensajes interceptará el comando antes de que sea procesado por el método del manejador de
comandos (`Commands Handler`). Utilizará el repositorio JPA para consultar la tabla de búsqueda y, si el registro ya
existe, el comando se bloqueará.

**¿Cómo vamos a escribir en esta tabla de consulta?**, implementaremos un manejador de eventos adicional que persistirá
el `ID del producto` y el `título` del producto en esta tabla de base de datos cuando el método del `Command Handler`
publique el evento `ProductCreatedEvent`.

## Crea la entidad Product Lookup

En el apartado anterior analizamos que debíamos crear una base de datos (`Lookup db table`) que almacene el `product Id`
y el `title` como una manera de identificar si un producto ya fue registrado, de esta manera evitaríamos registrar un
producto con los mismos datos.

En este apartado crearemos la entidad que nos permitirá guardar los identificadores de cada producto guardado.

````java

@AllArgsConstructor
@NoArgsConstructor
@Builder
@Data
@Entity
@Table(name = "products_lookup")
public class ProductLookupEntity {
    @Id
    private String productId;

    @Column(unique = true)
    private String title;
}
````
