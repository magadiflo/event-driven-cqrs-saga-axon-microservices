# Sección 07: Patrón CQRS en product-service

---

## Acepta Body HTTP Request

Vamos a crear una clase que nos permitirá mapear los valores enviados en el body de la petición.

````java

@Data
public class CreateProductRestModel {
    private String title;
    private BigDecimal price;
    private Integer quantity;
}
````

Ahora en el `ProductController` modificamos el endpoint `createProduct()` para mapear los valores enviados en el cuerpo
de la solicitud a una clase java.

````java

@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/products")
public class ProductController {

    private final Environment environment;

    /* otro endpoint */

    @PostMapping
    public String createProduct(@RequestBody CreateProductRestModel request) {
        return "HTTP POST Handled " + request.getTitle();
    }

    /* otros endpoints */
}
````

Para probar si los valores que estamos enviando se están mapeando a la clase java, vamos a realizar una petición
levantando los servicios en este orden:

1. Discover Server
2. Product Service
3. Gateway Server

Finalmente, realizamos la petición y vemos que todo está funcionando correctamente.

````bash
$ curl -v -X POST -H "Content-Type: application/json" -d "{\"title\": \"Samsung 20\", \"price\": 3500.50, \"quantity\": 10}" http://localhost:8080/api/v1/products
>
* upload completely sent off: 57 bytes
< HTTP/1.1 200 OK
< Content-Type: text/plain;charset=UTF-8
< Content-Length: 28
< Date: Tue, 07 Jan 2025 21:13:13 GMT
<
HTTP POST Handled Samsung 20
````

## Agrega dependencia de Axon Framework al Product Service

Antes de continuar debemos agregar a nuestro `product-service` la dependencia de `Axon Framework`.

````xml
<!-- https://mvnrepository.com/artifact/org.axonframework/axon-spring-boot-starter -->
<dependency>
    <groupId>org.axonframework</groupId>
    <artifactId>axon-spring-boot-starter</artifactId>
    <version>4.10.3</version>
</dependency>
````

#### Nota: Actualización de Axon Framework a la versión 4.7.0 (En mi caso es la 4.10)

> Desde que publicó este curso en video, `Axon Framework` se ha actualizado a una versión más reciente. Lamentablemente,
> hay algunos cambios importantes.
>
> Abra el siguiente enlace en una nueva ventana del
> navegador: [Actualización a la versión 4.7](https://docs.axoniq.io/axon-framework-reference/4.10/upgrading-to-4-7/).
> Manténgalo abierto mientras crea las primeras clases de su aplicación. Esta página contiene información sobre todos
> los cambios importantes y cómo resolverlos.

## Crea una nueva clase de comando

Cuando se nombran comandos en `CQRS`, hay una convención de nomenclatura:

````
<Verb><Noun>Command
````

En nuestro caso crearemos la clase de comando llamada `CreateProductCommand`. Esta clase la crearemos en el paquete
`command`, dado que estamos siguiendo el patrón de diseño `CQRS` donde debemos mostrar una clara separación entre
la API de comandos y la API de consultas.

````java
package dev.magadiflo.app.command;

import lombok.Builder;
import lombok.Data;
import org.axonframework.modelling.command.TargetAggregateIdentifier;

import java.math.BigDecimal;

@Data
@Builder
public class CreateProductCommand {
    @TargetAggregateIdentifier
    private final String productId;
    private final String title;
    private final BigDecimal price;
    private final Integer quantity;
}
````

Notar que a todos los atributos de la clase anterior las hemos definido como `final` con la finalidad de hacer esta
clase como una clase de solo lectura.

Además, hemos agregado un atributo llamado `productId` a quien lo anotamos con `@TargetAggregateIdentifier`.
`Axon Framework` utilizará este identificador para asociar este comando con un objeto agregado. Un Agregado será nuestro
objeto de dominio y manejará comandos, validará el comando y decidirá si el nuevo producto puede ser creado o si el
evento necesita ser borrado.

Función de `@TargetAggregateIdentifier`:

- `Identificación del agregado objetivo`: Axon Framework utiliza esta anotación para determinar a qué agregado debe
  enviarse un comando. En términos simples, indica que el valor de este campo (`productId` en tu caso) se utilizará para
  identificar el agregado que manejará el comando.


- `Asociación con el agregado`: Cuando se maneja un comando, el marco necesita saber cuál instancia de un agregado
  específico debe procesarlo. El valor del campo marcado con esta anotación le proporciona al Axon Framework la clave
  para buscar el agregado correspondiente.

Contexto en tu clase `CreateProductCommand`:

- La clase define un comando (`CreateProductCommand`) que probablemente se envíe para crear un producto.
- El `productId`, marcado con `@TargetAggregateIdentifier`, asegura que `Axon Framework` sepa a cuál agregado de
  producto (`ProductAggregate`, por ejemplo) está destinado este comando.
- Esto es crucial en sistemas `CQRS` y `Event Sourcing`, donde los comandos se enrutan a agregados específicos para
  ejecutar acciones que alteran su estado.

## Crea un nuevo objeto de CreateProductCommand

Como ya tenemos creado nuestra clase `CreateProductCommand`, por ahora continuaremos creando un objeto de esta clase
almacenando los valores obtenidos del request.

````java

@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/products")
public class ProductController {

    private final Environment environment;

    /* other endpoint */

    @PostMapping
    public String createProduct(@RequestBody CreateProductRestModel request) {
        CreateProductCommand createProductCommand = CreateProductCommand.builder()
                .price(request.getPrice())
                .quantity(request.getQuantity())
                .title(request.getTitle())
                .productId(UUID.randomUUID().toString())
                .build();
        return "HTTP POST Handled " + request.getTitle();
    }

    /* other endpoints */
}
````

## Envía comando a un Gateway de comandos

Un `Command Gateway` es un objeto que será usado para enviar este objeto de comando que tenemos creado a un
`Command Bus`. Pensemos en un `Command Gateway` como una api para enviar comandos y el `Command Bus` es un mecanismo
que recibe este comando y luego activa este comando en un controlador de comandos. Nosotros aún no tenemos ningún
controlador de comandos, pero crearemos uno más adelante.

En este momento necesitamos un `Command Gateway` para enviar el objeto `CreateProductCommand` a un `Command Bus`.

En el siguiente diagrama se muestra el `Command Bus` para ayudarnos a visualizar mejor el panorama en la
arquitectura de `Axon`.

El `Command Bus` es un mecanismo que envía comandos a sus respectivos controladores de comandos. Cada comando siempre
es enviado exactamente a un controlador de comandos y si no hay un controlador de comandos disponible para un
`dispatch command`, una excepción será lanzada.

![01.jpeg](assets/section-07/01.jpeg)

A continuación se muestra nuestra clase controladora `ProductController` donde estamos inyectando el `CommandGateway`
importado de `org.axonframework.commandhandling.gateway.CommandGateway`.

````java

@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/products")
public class ProductController {

    private final Environment environment;
    private final CommandGateway commandGateway;

    /* another endpoint */

    @PostMapping
    public String createProduct(@RequestBody CreateProductRestModel request) {
        CreateProductCommand createProductCommand = CreateProductCommand.builder()
                .price(request.getPrice())
                .quantity(request.getQuantity())
                .title(request.getTitle())
                .productId(UUID.randomUUID().toString())
                .build();

        String returnValue;
        try {
            returnValue = this.commandGateway.sendAndWait(createProductCommand);
        } catch (Exception e) {
            returnValue = e.getLocalizedMessage();
        }
        return returnValue;
    }

    /* other endpoints */
}
````

El uso del `CommandGateway` y específicamente del método `sendAndWait` en `Axon Framework` tiene como objetivo
simplificar el envío de comandos dentro de tu aplicación.

#### ¿Qué es el CommandGateway?

- Es una interfaz proporcionada por `Axon Framework` para enviar comandos a los agregados de manera sencilla.
- Abstrae los detalles de cómo se envían los comandos y cómo se manejan sus respuestas.

#### ¿Qué hace el método sendAndWait?

- `Envío del comando`: Envía el comando al `Bus de Comandos de Axon`.
- `Espera una respuesta`: Pausa la ejecución del código hasta que el comando sea procesado y devuelva una respuesta o
  lance una excepción.
    - Si el comando se procesa correctamente, devuelve un valor (puede ser un ID o un mensaje).
    - Si ocurre algún problema (como una validación fallida), lanza una excepción.

En nuestro caso, estás enviando el comando `CreateProductCommand`, que probablemente será manejado por un agregado como
`ProductAggregate`.

## ProductAggregate - Introducción

La clase agregada es el núcleo de nuestro microservicio, es su objeto de dominio, contiene el estado actual del objeto
principal.

En este apartado estamos trabajando con el `product-service`, eso significa que nuestra clase agregada se llamará
`ProductAggregate`. Este objeto `ProductAggregate` contendrá el estado actual del objeto producto. Así que mantendrá
el valor actual del título del producto, mantendrá el valor actual del precio del producto y el valor actual de la
cantidad del producto.

Adicionalmente, al estado actual, el `ProductAggregate` contendrá métodos que puedan manejar comandos. Por ejemplo,
cuando se envíe un comando para crear producto, será un método de la clase agregada el que lo maneje.

El `ProductAggregate` también tendrá una lógica de negocio, por ejemplo cuando gestione la orden de crear un producto
será necesario validar esta orden y decidir si se puede crear o no.

El `ProductAggregate` contendrá métodos de control de origen de eventos y cada vez que cambie un estado de la
información del producto, se invocará un método de origen de eventos. Además, cuando se recibe un comando para
actualizar los detalles del producto, por ejemplo, el estado de este objeto agregado del producto, primero tendrá que
ser cargado desde el almacén de eventos.

Así que lo que sucederá es esto, `Axon Framework` creará primero un nuevo objeto vacío de la clase `ProductAggregate`,
y es por eso que necesita un constructor vacío. A continuación, leerá cada uno de los eventos almacenados en el almacén
de eventos para este agregado y aplicará ese evento al agregado.

![02.png](assets/section-07/02.png)

## Crea la clase ProductAggregate

Esta clase es un agregado en el contexto del patrón `CQRS` y `Event Sourcing`. Un agregado en `Axon Framework`
representa un componente central que maneja comandos y encapsula las reglas de negocio. Aquí está estructurada para
manejar un comando llamado `CreateProductCommand`.

````java
package dev.magadiflo.app.command;

import lombok.NoArgsConstructor;
import org.axonframework.commandhandling.CommandHandler;
import org.axonframework.spring.stereotype.Aggregate;

@NoArgsConstructor
@Aggregate
public class ProductAggregate {

    @CommandHandler
    public ProductAggregate(CreateProductCommand createProductCommand) {
        // validate create product command
    }

}
````

1. `@Aggregate`
    - `Propósito`: Marca esta clase como un agregado raíz en Axon Framework. Declara que esta clase es un agregado
      manejado por Axon.
    - `Función`:
        - Permite que Axon reconozca esta clase como un componente responsable de manejar comandos relacionados con una
          entidad lógica.
        - Internamente, Axon asegura que el estado del agregado esté gestionado adecuadamente (ya sea cargándolo desde
          la base de datos o reconstruyéndolo a partir de eventos, dependiendo de tu configuración).

2. `@CommandHandler`
    - `Propósito`: Marca un método o constructor para manejar un comando específico.
    - `Función`:
        - Este constructor se ejecuta cuando se recibe un comando del tipo `CreateProductCommand`.
        - Es aquí donde se valida el comando y se ejecuta la lógica necesaria para inicializar el estado del agregado.

3. `@NoArgsConstructor`, genera un constructor sin argumentos utilizando Lombok. `Axon Framework` requiere un
   constructor sin argumentos en los agregados para reconstruir su estado a partir de eventos (en el caso de
   `Event Sourcing`).

### Flujo del Constructor con @CommandHandler

1. Cuando un comando `CreateProductCommand` se envía al agregado a través del `CommandGateway`, `Axon` busca un
   manejador para este comando en la clase marcada con `@Aggregate`.
2. Encuentra el constructor marcado con `@CommandHandler`.
3. Ejecuta el constructor, donde puedes realizar:
    - Validaciones del comando.
    - Lógica de negocio inicial (como inicializar el estado del agregado).
    - Generar eventos si es necesario.
