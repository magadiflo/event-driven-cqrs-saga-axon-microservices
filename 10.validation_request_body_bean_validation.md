# Sección 10: Validación del Request Body. Bean Validation

---

## Java Bean Validation

Para realizar las validaciones agregamos la siguiente dependencia al `pom.xml` del `product-service`.

````xml

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
````

Además, es importante definir las siguientes propiedades en el `application.yml`

````yml
server:
  error:
    include-message: always
    include-binding-errors: always
````

1. `server.error.include-message: always`

    - Esta propiedad controla si el mensaje de error detallado se incluirá en la respuesta cuando ocurra un error en la
      aplicación.
    - El valor `always` significa que el mensaje de error siempre se incluirá en la respuesta, lo que puede ser útil
      para depuración, pero podría exponer información sensible en un entorno de producción.
    - Otras opciones posibles son:
        - `never` (nunca incluir el mensaje de error).
        - `on_param` (incluirlo solo si el cliente proporciona un parámetro especial en la solicitud).


2. `server.error.include-binding-errors: always`

    - Esta propiedad determina si los errores de validación de binding (errores que ocurren cuando los datos de la
      solicitud no cumplen con las restricciones de validación) se incluyen en la respuesta de error.
    - Con el valor `always`, Spring Boot siempre incluirá los errores de validación en la respuesta cuando se detecte un
      problema en los datos enviados.
    - Otras opciones posibles:
        - `never` (nunca incluir detalles de errores de binding).
        - `on_param` (incluirlos solo si se proporciona un parámetro específico en la solicitud).

## Valida el cuerpo de la solicitud

En este apartado aplicaremos validación al dto `CreateProductRestModel`, dado que el cuerpo de la solicitud se va a
mapear a esta clase java. Para eso, en el endpoint `createProduct` de nuestro controlador `ProductCommandController`
agregamos la anotación `@Valid` justo antes del `@RequestBody CreateProductRestModel` para que active las validaciones
para esta clase java `(CreateProductRestModel)`.

````java

@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/products")
public class ProductCommandController {

    private final CommandGateway commandGateway;

    @PostMapping
    public String createProduct(@Valid @RequestBody CreateProductRestModel request) {
        CreateProductCommand createProductCommand = CreateProductCommand.builder()
                .price(request.getPrice())
                .quantity(request.getQuantity())
                .title(request.getTitle())
                .productId(UUID.randomUUID().toString())
                .build();

        String returnValue;
        try {
            returnValue = this.commandGateway.sendAndWait(createProductCommand);
        } catch (Exception e) {
            returnValue = e.getLocalizedMessage();
        }
        return returnValue;
    }
}
````

Ahora, en la clase `CreateProductRestModel` agregamos las anotaciones (`@NotBlank`, `@Min`, `@Max`, etc.) a cada
atributo al que queramos validar según nuestras reglas de negocio.

````java

@Data
public class CreateProductRestModel {
    @NotBlank(message = "Product title is a required field")
    private String title;

    @Min(value = 1, message = "Price must be greater than or equal to 1")
    private BigDecimal price;

    @Min(value = 0, message = "Quantity must be greater than or equal to zero")
    @Max(value = 5, message = "Quantity must be less than or equal to 5")
    private Integer quantity;
}
````
