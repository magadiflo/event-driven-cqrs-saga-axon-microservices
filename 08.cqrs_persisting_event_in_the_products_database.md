# Sección 08: Persiste evento en la base de datos de productos

---

## Agrega dependencia de Spring Data JPA y PostgreSQL

Agregaremos las siguientes dos dependencias al `pom.xml` del `product-service`.

````xml

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <scope>runtime</scope>
    </dependency>
</dependencies>
````

## Configura acceso a base de datos en el application.yml

En el `application.yml` del `product-service` agregamos las siguientes configuraciones hacia nuestra base de datos.

````yml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5435/db_product_service
    username: magadiflo
    password: magadiflo
  jpa:
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        format_sql: true

logging:
  level:
    dev.magadiflo.app: DEBUG
    org.hibernate.SQL: DEBUG
````

En la raíz del proyecto general vamos a crear un directorio llamado `/docker` y dentro de él crearemos un archivo
llamado `compose.yml` donde agregaremos la configuración para generar un contenedor de la base de datos para nuestro
`product-service`.

````yml
services:
  postgres:
    image: postgres:15.2-alpine
    container_name: c-product-service-postgres
    restart: unless-stopped
    environment:
      POSTGRES_DB: db_product_service
      POSTGRES_USER: magadiflo
      POSTGRES_PASSWORD: magadiflo
    ports:
      - "5435:5432"
    volumes:
      - postgres_axon_product_data:/var/lib/postgresql/data
    networks:
      - axon_network

volumes:
  postgres_axon_product_data:
    name: postgres_axon_product_data

networks:
  axon_network:
    name: axon_network
````

A continuación, nos posicionamos dentro del directorio `/docker` y ejecutamos el archivo `compose.yml` con el siguiente
comando.

````bash
M:\PERSONAL\PROGRAMACION\DESARROLLO_JAVA_SPRING\01.udemy\05.sergey_kargopolov\event-driven-cqrs-saga-axon-microservices\docker (main -> origin)
$ docker compose up -d                                                                                                                         
[+] Running 3/3                                                                                                                                
 ✔ Network axon_network                  Created                                                                                               
 ✔ Volume "postgres_axon_product_data"   Created                                                                                               
 ✔ Container c-product-service-postgres  Started                                                                                                                                                                                             
````

Si ahora listamos los contenedores, veremos que nuestro contenedor `c-product-service-postgres` se ha creado
correctamente y está levantado (`Up`).

````bash
$ docker container ls -a
CONTAINER ID   IMAGE                                       COMMAND                  CREATED          STATUS                      PORTS                    NAMES
226986e7344b   postgres:15.2-alpine                        "docker-entrypoint.s…"   34 seconds ago   Up 33 seconds               0.0.0.0:5435->5432/tcp   c-product-service-postgres
````

Si listamos el volumen del contenedor, vemos que se ha creado sin problemas.

````bash
$ docker volume ls
DRIVER    VOLUME NAME
local     postgres_axon_product_data
````

Incluso, vemos que se ha creado correctamente el network definido en el archivo `compose.yml`.

````bash
$ docker network ls
NETWORK ID     NAME             DRIVER    SCOPE
c86450db1e87   axon_network     bridge    local
````

Si ahora utilizamos `DBeaver`, nos podemos conectar fácilmente a la base de dato que acabamos de levantar usando un
contenedor de `Docker`.

![01.png](assets/section-08/01.png)

También podríamos entrar a la base de datos a través del contenedor mismo. Utilizando el siguiente comando ingresamos
dentro del contenedor, colocamos el usuario y nombre de la base de datos y listamos las tablas existentes. Como aún
no tenemos ninguna tabla nos mostrará el mensaje `Did not find any relations`.

````bash
$ docker container exec -it c-product-service-postgres /bin/sh
/ # psql -U magadiflo -d db_product_service
psql (15.2)
Type "help" for help.

db_product_service=# \dt
Did not find any relations.
````

## Crea el ProductEntity

En el `product-service` creamos la siguiente entidad `ProductEntity` que será mapeado a la tabla `products` de la
base de datos.

````java

@AllArgsConstructor
@NoArgsConstructor
@Builder
@Data
@Entity
@Table(name = "products")
public class ProductEntity {
    @Id
    private String productId;

    @Column(unique = true)
    private String title;

    private BigDecimal price;

    private Integer quantity;
}
````

## Crea ProductRepository

En este apartado crearemos el repositorio para nuestro `ProductEntity`, donde definiremos dos métodos personalizados
utilizando los `Query Methods` de `Spring Data JPA`. Estos métodos permiten generar consultas automáticamente basándose
en los nombres de los métodos, siguiendo una convención predefinida.

`Spring Data JPA` analiza el nombre del método y lo traduce en una consulta `JPQL (Java Persistence Query Language)` o
`SQL`, dependiendo del repositorio configurado. Este mecanismo se basa en el parsing de los nombres de los métodos.

````java
public interface ProductRepository extends JpaRepository<ProductEntity, String> {
    Optional<ProductEntity> findByProductId(String productId);

    Optional<ProductEntity> findByProductIdOrTitle(String productId, String title);
}
````

En nuestro caso:

1. `findByProductId(String productId)`
    - El prefijo `findBy` indica que es una consulta de búsqueda.
    - `ProductId` especifica el campo de la entidad `ProductEntity` que se utiliza como criterio de búsqueda.

2. `findByProductIdOrTitle(String productId, String title)`
    - El operador `Or` permite buscar registros que coincidan con cualquiera de las dos condiciones: `productId` o
      `title`.

## Crea Handler/Projection de eventos de productos

En este apartado crearemos una clase manejadora de eventos. Un método en esta clase manejará un evento publicado por
nuestro objeto `ProductAggregate` y persistirá la información sobre el producto creado en la tabla `products` de la
base de datos.

A menudo, este tipo de clases se les llama `projection`, por ejemplo, podríamos llamar a esta clase `ProductProjection`
en lugar de `ProductEventsHandler`. Podemos elegir el nombre que queramos, en nuestro caso utilizaremos
`ProductEventsHandler`.

````java

@Component
public class ProductEventsHandler {

    @EventHandler
    public void on(ProductCreatedEvent event) {

    }
}
````

Esta clase es un `event handler` o manejador de eventos, lo que significa que está diseñada para escuchar y reaccionar
a eventos que ocurren en tu sistema. En este caso, el evento que está escuchando es un `ProductCreatedEvent`.

La anotación `@EventHandler` marca un método que será invocado cuando se dispare un evento específico en el sistema de
`Axon Framework`. En este caso, el método `on(ProductCreatedEvent event)` será llamado cada vez que un
`ProductCreatedEvent` sea publicado.

- `¿Cómo funciona?`, cuando el método `AggregateLifecycle.apply(productCreatedEvent)` en tu agregado `ProductAggregate`
  se ejecuta, `Axon` publica este evento (`ProductCreatedEvent`) en su bus de eventos. Todos los métodos anotados con
  `@EventHandler` y que manejan este tipo de evento serán ejecutados automáticamente.

- `Parámetro del método`, el evento `ProductCreatedEvent` que llega como parámetro contiene los datos relevantes (como
  `productId`, `title`, `price`, `quantity`). Puedes usar esta información para realizar acciones adicionales, como
  persistir datos en la base de datos.

## Implementando el método anotado con @EventHandler

En este apartado implementamos el método `on`, que actúa como manejador del evento `ProductCreatedEvent`. Dentro de
este método, creamos un objeto `ProductEntity` utilizando la información contenida en el evento. Luego, usamos la
interfaz `ProductRepository` para guardar este objeto como un nuevo registro en la tabla `products` de la base
de datos, garantizando que los datos emitidos por el evento sean persistidos correctamente.

En general, el flujo sería así:

1. En el agregado `ProductAggregate`, cuando se dispara el evento `ProductCreatedEvent` (con
   `AggregateLifecycle.apply`), `Axon Framework` publica el evento en el bus de eventos.
2. `Axon` detecta todas las clases con métodos anotados con `@EventHandler` que manejan ese tipo de evento. En este
   caso, el método `on(ProductCreatedEvent event)` es identificado como un manejador.
3. `Axon` invoca este método automáticamente, pasando los datos del evento.
4. El método usa esos datos para construir un objeto de la entidad `ProductEntity` y lo guarda en la base de datos a
   través del repositorio.

````java

@RequiredArgsConstructor
@Component
public class ProductEventsHandler {

    private final ProductRepository productRepository;

    @EventHandler
    public void on(ProductCreatedEvent event) {

        ProductEntity productEntity = ProductEntity.builder()
                .productId(event.getProductId())
                .title(event.getTitle())
                .price(event.getPrice())
                .quantity(event.getQuantity())
                .build();

        this.productRepository.save(productEntity);
    }
}
````